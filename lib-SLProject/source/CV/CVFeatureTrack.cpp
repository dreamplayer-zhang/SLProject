//#############################################################################
//  File:      CVTrackedWAI.cpp
//  Author:    Michael Goettlicher, Jan Dellsperger
//  Date:      Spring 2020
//  Codestyle: https://github.com/cpvrlab/SLProject/wiki/SLProject-Coding-Style
//  Copyright: Marcus Hudritsch, Michael Goettlicher
//             This software is provide under the GNU General Public License
//             Please visit: http://opensource.org/licenses/GPL-3.0
//#############################################################################

#include <CVFeatureTrack.h>
#include <SL.h>
#include <Instrumentor.h>
#include <F2FTransform.h>
#include <SLMat4.h>

//-----------------------------------------------------------------------------
CVFeatureTrack::CVFeatureTrack()
{
    float startMS = _timer.elapsedTimeInMilliSec();
    int   nf           = 500; // NO. of features
    float fScaleFactor = 1.2f; // Scale factor for pyramid construction
    int   nLevels      = 2;    // NO. of pyramid levels
    int   fIniThFAST   = 10;   // Init threshold for FAST corner detector
    int   fMinThFAST   = 7;    // Min. threshold for FAST corner detector
    _trackingExtractor = new ORB_SLAM2::ORBextractor(nf,
                                                     fScaleFactor,
                                                     nLevels,
                                                     fIniThFAST,
                                                     fMinThFAST);

    _Tcw          = cv::Mat::eye(4, 4, CV_32F);
    _Tcw.copyTo(_objectViewMat);
    _hasLastFrame = false;
    _yaw          = 0;
    _pitch        = 0;
    _roll         = 0;
}
//-----------------------------------------------------------------------------
CVFeatureTrack::~CVFeatureTrack()
{
    delete _trackingExtractor;
}
//-----------------------------------------------------------------------------
/*! This function is called every frame in the apps onUpdateVideo function.
 It uses the on-the-fly built 3D point cloud generated by the ORB-SLAM2 library
 that is integrated within the lib-WAI. It only works well if the camera is
 calibrated.
 @param imageGray Image for processing
 @param imageRgb Image for visualizations
 @param calib Pointer to a valid camera calibration
 @return returns true if pose estimation was successful
 */
bool CVFeatureTrack::track(CVMat          imageGray,
                           CVMat          imageRgb,
                           CVCalibration* calib)
{
    PROFILE_FUNCTION();
    cv::Mat  intrinsic  = calib->cameraMat();
    cv::Mat  distortion = calib->distortion();

    WAIFrame frame = WAIFrame(imageGray,
                              _trackingExtractor,
                              intrinsic,
                              distortion);

    if (!_hasLastFrame)
    {
        _lastFrame = WAIFrame(frame);
        _lastFrame.SetPose(_Tcw);
        _hasLastFrame = true;
        _lastImageGray = imageGray.clone();
        return false;
    }


    F2FTransform::opticalFlowMatch(_lastImageGray,
                                   imageGray,
                                   _lastFrame.mvKeysUn,
                                   ps1,
                                   ps2,
                                   inliers,
                                   err);

    float m = F2FTransform::filterPoints(ps1,
                                         ps2,
                                         goodPs1,
                                         goodPs2,
                                         inliers,
                                         err);

    if (m < 2)
        return false;

    for (unsigned int i = 0; i < goodPs1.size(); i++)
    {
            cv::Point2f p1 = goodPs1[i];
            cv::Point2f p2 = goodPs2[i];
            cv::line(imageRgb, p1, p2, cv::Scalar(0, 255, 0));
    }

    bool ret;
    float yaw, pitch, roll;
    ret = F2FTransform::estimateRot(intrinsic, goodPs1, goodPs2, yaw, pitch, roll);

    if (ret)
    {
        cv::Mat Rx, Ry, Rz, Tcw;
        _yaw += yaw;
        _pitch += pitch;
        _roll += roll;
        F2FTransform::eulerToMat(_yaw, _pitch, _roll, Rx, Ry, Rz);
        Tcw = Rx * Ry * Rz;
        cv::Mat pos = cv::Mat::eye(4, 4, CV_32F);
        pos.at<float>(2, 3) = -1.5;
        pos = Tcw * pos;
        pos.copyTo(_objectViewMat);
    }
    _lastImageGray = imageGray.clone();
    _lastFrame = WAIFrame(frame);
    return ret;
}
//-----------------------------------------------------------------------------
