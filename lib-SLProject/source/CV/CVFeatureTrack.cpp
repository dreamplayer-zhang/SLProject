//#############################################################################
//  File:      CVTrackedWAI.cpp
//  Author:    Michael Goettlicher, Jan Dellsperger
//  Date:      Spring 2020
//  Codestyle: https://github.com/cpvrlab/SLProject/wiki/SLProject-Coding-Style
//  Copyright: Marcus Hudritsch, Michael Goettlicher
//             This software is provide under the GNU General Public License
//             Please visit: http://opensource.org/licenses/GPL-3.0
//#############################################################################

#include <CVFeatureTrack.h>
#include <SL.h>
#include <Instrumentor.h>
#include <F2FTransform.h>
#include <SLMat4.h>

//-----------------------------------------------------------------------------
CVFeatureTrack::CVFeatureTrack()
{
    float startMS = _timer.elapsedTimeInMilliSec();
    int   nf           = 1000; // NO. of features
    float fScaleFactor = 1.2f; // Scale factor for pyramid construction
    int   nLevels      = 2;    // NO. of pyramid levels
    int   fIniThFAST   = 10;   // Init threshold for FAST corner detector
    int   fMinThFAST   = 7;    // Min. threshold for FAST corner detector
    _trackingExtractor = new ORB_SLAM2::ORBextractor(nf,
                                                     fScaleFactor,
                                                     nLevels,
                                                     fIniThFAST,
                                                     fMinThFAST);

    _Tcw          = cv::Mat::eye(4, 4, CV_32F);
    _Tcw.copyTo(_objectViewMat);
    _hasLastFrame = false;
}
//-----------------------------------------------------------------------------
CVFeatureTrack::~CVFeatureTrack()
{
    delete _trackingExtractor;
}
//-----------------------------------------------------------------------------
/*! This function is called every frame in the apps onUpdateVideo function.
 It uses the on-the-fly built 3D point cloud generated by the ORB-SLAM2 library
 that is integrated within the lib-WAI. It only works well if the camera is
 calibrated.
 @param imageGray Image for processing
 @param imageRgb Image for visualizations
 @param calib Pointer to a valid camera calibration
 @return returns true if pose estimation was successful
 */
bool CVFeatureTrack::track(CVMat          imageGray,
                           CVMat          imageRgb,
                           CVCalibration* calib)
{
    PROFILE_FUNCTION();
    cv::Mat  intrinsic  = calib->cameraMat();
    cv::Mat  distortion = calib->distortion();

    WAIFrame frame = WAIFrame(imageGray,
                              _trackingExtractor,
                              intrinsic,
                              distortion);

    if (!_hasLastFrame)
    {
        _lastFrame = WAIFrame(frame);
        _lastFrame.SetPose(_Tcw);
        _hasLastFrame = true;
        _lastImageGray = imageGray.clone();
        return false;
    }
 
    std::vector<cv::Point2f> p1;
    std::vector<cv::Point2f> p2;

    float m = F2FTransform::OpticalFlowMatch(_lastImageGray,
                                             imageGray,
                                             _lastFrame.mvKeysUn,
                                             p1,
                                             p2);

    if (m < 2)
        return false;

    for (unsigned int i = 0; i < p1.size(); i++)
    {
        p1[i].x += imageGray.rows/2;
        p2[i].x += imageGray.rows/2;
        p1[i].y += imageGray.cols/2;
        p2[i].y += imageGray.cols/2;
        cv::line(imageRgb, p1[i], p2[i], cv::Scalar(0, 255, 0));
    }

    bool ret;
    cv::Mat tcw;

    ret = F2FTransform::EstimateRot(intrinsic, p1, p2, tcw); 

    //ret = F2FTransform::FindTransform(intrinsic, p1, p2, tcw);
    //ret = F2FTransform::EstimateRot(intrinsic, p1, p2, tcw);

    if (ret)
    {
        _Tcw = tcw * _Tcw;
        cv::Mat pos = cv::Mat::eye(4, 4, CV_32F);
        pos.at<float>(2, 3) = -1.5;
        pos = _Tcw * pos;
        pos.copyTo(_objectViewMat);
    }
    _lastImageGray = imageGray.clone();
    _lastFrame = WAIFrame(frame);
    return ret;
}
//-----------------------------------------------------------------------------
